// Generated by CoffeeScript 1.12.2
(function() {
  var RedCameraConnection, consoleOutput, eventEmitter, getInitialInfo, ipConnection, redFunctions, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ipConnection = require('./ip.js');

  eventEmitter = require('events').EventEmitter;

  util = require('util');

  redFunctions = require('./redFunctions.js');

  RedCameraConnection = (function() {
    var handelData, handelParsedString, parseDataForTransmit;

    function RedCameraConnection() {
      this.sendCommand = bind(this.sendCommand, this);
      this.disconnect = bind(this.disconnect, this);
      this.getStatus = bind(this.getStatus, this);
      this.connect = bind(this.connect, this);
      this.connection = new ipConnection();
      this.status = {};
      this.id = null;
      this.ip = null;
      this.port = 1111;
      this.timeout = 1000;
      this.autoReconnect = true;
      this.verbose = true;
      this.buffer = Buffer.alloc(200, 0, 'base64');
      this.connection.on('status', (function(_this) {
        return function(data) {
          _this.emit('status', data);
          switch (data) {
            case 2:
              _this.status.connected = true;
              getInitialInfo(_this);
              break;
            default:
              _this.status.lists = {};
              _this.status.current = {};
              _this.status.notify = {};
              _this.status.connected = false;
          }
          if (data !== 2) {
            return _this.status.connected = false;
          }
        };
      })(this));
      this.connection.on('statusVb', (function(_this) {
        return function(data) {
          _this.emit('statusVB', data);
          return consoleOutput(data);
        };
      })(this));
      this.connection.on('data', (function(_this) {
        return function(data) {
          _this.emit('data', data);
          _this.buffer += data;
          return _this.buffer = handelData(_this.buffer, _this);
        };
      })(this));
    }

    RedCameraConnection.prototype.connect = function(ip, autoReconnect, timeout, port) {
      consoleOutput("connection triggerd to " + ip + " \t autoReconnect:" + autoReconnect + " \t timeout: " + timeout);
      this.ip = ip;
      if (port) {
        this.port = port;
      }
      if (typeof autoReconnect === "boolean") {
        this.autoReconnect = autoReconnect;
      } else {
        consoleOutput("none or none valid autoReconnect value using te default setting " + autoReconnect);
      }
      if ((typeof timeout === 'number' && (timeout % 1) === 0) && timeout >= 0) {
        this.timeout = timeout;
      } else {
        consoleOutput("timeout not a valid integer");
        this.emit('statusVb', "timeout not a valid integer");
        this.emit('status', 6);
      }
      if (!this.connection.connect(this.ip, this.port, this.timeout)) {
        consoleOutput("connection failed (ip.js)");
        this.emit('statusVb', "connection failed");
        return this.emit('status', 6);
      }
    };

    RedCameraConnection.prototype.getStatus = function() {
      return this.status;
    };

    RedCameraConnection.prototype.disconnect = function() {
      this.connection.disconnect();
      return this.status.connected = false;
    };

    RedCameraConnection.prototype.sendCommand = function(type, value) {
      var msg, msgres;
      if (this.status.connected) {
        msg = "$EXT:" + type + ":" + value + ":";
        msgres = parseDataForTransmit(msg);
        if (msgres === false) {
          consoleOutput("msg Not Valid: " + msg);
          return this.emit('statusVB', "msg Not Valid: " + msg);
        } else {
          return this.connection.write(msgres);
        }
      } else {
        console.log(this.status);
        consoleOutput("not connected to " + this.ip + " so can't send a msg");
        return this.emit('statusVB', "not connected to " + this.ip + " so can't send a msg");
      }
    };

    handelData = function(buffer, thisRef) {
      var parsedString, splitPosition, stringToParse;
      splitPosition = buffer.indexOf('\n');
      while (splitPosition !== -1) {
        stringToParse = buffer.substring(0, splitPosition);
        buffer = buffer.substring(splitPosition + 1);
        parsedString = redFunctions.parseLine(stringToParse);
        if (parsedString) {
          handelParsedString(parsedString, thisRef);
        }
        splitPosition = buffer.indexOf('\n');
      }
      return buffer;
    };

    handelParsedString = function(parsedString, thisRef) {
      var target;
      target = null;
      if (parsedString[3] !== "NOTIFY") {
        if (parsedString[2] === "D") {
          target = "lists";
        }
        if (parsedString[2] === "C") {
          target = "current";
        }
        if (target) {
          thisRef.emit("cameraStatusUpdate", parsedString[2], parsedString[3], parsedString[4]);
          thisRef.status[target][parsedString[3]] = parsedString[4];
        }
        if (parsedString[3] === "XXX") {
          return console.log('bla');
        }
      } else {
        console.log("handel notify msg");
        return console.log(parsedString);
      }
    };

    parseDataForTransmit = function(data) {
      var checksum;
      if (!redFunctions.checkIfValid(data)) {
        return false;
      }
      checksum = redFunctions.calcChecksum(data);
      data = "#" + data;
      data += "*" + checksum;
      data += "\n";
      return data;
    };

    return RedCameraConnection;

  })();

  getInitialInfo = (function(_this) {
    return function(thisRef) {
      var i, j, len, len1, ref, ref1, results, value;
      ref = redFunctions.gValues;
      for (i = 0, len = ref.length; i < len; i++) {
        value = ref[i];
        thisRef.sendCommand("G", value);
      }
      ref1 = redFunctions.hValues;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        value = ref1[j];
        results.push(thisRef.sendCommand("H", value));
      }
      return results;
    };
  })(this);

  consoleOutput = function(data) {
    if (RedCameraConnection.verbose) {
      return console.log(data);
    }
  };

  util.inherits(RedCameraConnection, eventEmitter);

  module.exports = RedCameraConnection;

}).call(this);
