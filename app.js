// Generated by CoffeeScript 1.12.2
(function() {
  var Connection, connections, datetime, i, server, settings;

  server = require('./web.js');

  Connection = require('./redCamera.js');

  connections = [];

  settings = {
    'nrOfConnections': 10
  };

  datetime = function() {
    var currentdate, date, hour, min, month, sec, year;
    currentdate = new Date();
    date = currentdate.getDate();
    month = currentdate.getMonth() + 1;
    year = currentdate.getFullYear();
    hour = '00' + currentdate.getHours();
    hour = hour.slice(-2);
    min = '00' + currentdate.getMinutes();
    min = min.slice(-2);
    sec = '00' + currentdate.getSeconds();
    sec = sec.slice(-2);
    return date + "/" + month + "/" + year + " @ " + hour + ":" + min + ":" + sec;
  };

  i = 1;

  while (i <= settings.nrOfConnections) {
    connections[i] = new Connection();
    connections[i].on('statusVB', function(data) {
      return console.log("app.js\t" + (connections.indexOf(this)) + "\t" + (datetime()) + "\t(statusVB): " + data);
    });
    i++;
  }

  server.start(connections, settings);

  process.stdin.setEncoding('utf8');

  process.stdin.on('readable', (function(_this) {
    return function() {
      var chunk, error, pattr, res;
      chunk = process.stdin.read();
      pattr = /^([\w]+)\s?([0-9]+)?\s?([^\s]+)?\s?([^\s]+)?\s?([^\s]+)?\n/;
      res = pattr.exec(chunk);
      if (chunk !== null) {
        switch (res[1]) {
          case "status":
            try {
              return console.log(JSON.stringify(connections[res[2]].status, null, '\t'));
            } catch (error1) {
              error = error1;
              return console.log("error while status\n" + error);
            }
            break;
          case "disconnect":
            try {
              return connections[res[2]].disconnect();
            } catch (error1) {
              error = error1;
              return console.log("error while trying disconnect\n " + error);
            }
            break;
          case "connect":
            try {
              return connections[res[2]].connect(res[3], true, 0, 8888);
            } catch (error1) {
              error = error1;
              return console.log("error while trying connect\n " + error);
            }
            break;
          case "setstatus":
            try {
              if (res[3] === "C") {
                return connections[res[2]].status.current[res[4]] = res[5];
              } else if (res[3] === "D") {
                return connections[res[2]].status.list[res[4]] = res[5];
              }
            } catch (error1) {
              error = error1;
              return console.log("error while trying setstatus\n " + error);
            }
            break;
          default:
            return console.log('not a option');
        }
      }
    };
  })(this));

}).call(this);
